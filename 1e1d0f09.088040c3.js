(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{76:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return i})),r.d(t,"metadata",(function(){return s})),r.d(t,"toc",(function(){return h})),r.d(t,"default",(function(){return c}));var n=r(3),a=r(7),o=(r(0),r(95)),i={id:"a-star-search",title:"A* search algorithm",sidebar_label:"A* search"},s={unversionedId:"algorithms/shortest-path/a-star-search",id:"algorithms/shortest-path/a-star-search",isDocsHomePage:!1,title:"A* search algorithm",description:"A* algorithm is a graph traversal and path search algorithm often used in many fields of computer science. Starting from the starting node, it aims to find the path to the target node having the smallest cost.",source:"@site/docs/algorithms/shortest-path/a-star-search.md",slug:"/algorithms/shortest-path/a-star-search",permalink:"/algorithms/shortest-path/a-star-search",editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/shortest-path/a-star-search.md",version:"current",sidebar_label:"A* search",sidebar:"networkx_guide",previous:{title:"Dijkstra\u2019s algorithm",permalink:"/algorithms/shortest-path/dijkstra"},next:{title:"Floyd-Warshall algorithm",permalink:"/algorithms/shortest-path/floyd-warshall"}},h=[{value:"How does it work?",id:"how-does-it-work",children:[]},{value:"The difference from other shortest path algorithms",id:"the-difference-from-other-shortest-path-algorithms",children:[]},{value:"Pseudocode",id:"pseudocode",children:[]},{value:"Usage in NetworkX",id:"usage-in-networkx",children:[{value:"Method input",id:"method-input",children:[]},{value:"Method output",id:"method-output",children:[]},{value:"Example",id:"example",children:[]}]}],l={toc:h};function c(e){var t=e.components,r=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"A* algorithm is a graph traversal and path search algorithm often used in many fields of computer science. Starting from the starting node, it aims to find the path to the target node having the smallest cost. "),Object(o.b)("h2",{id:"how-does-it-work"},"How does it work?"),Object(o.b)("p",null,"A* search algorithm combines information from Dijkstra\u2019s algorithm and the Greedy Best-First-Search algorithm. Dijkstra\u2019s algorithm favours vertices that are closer to the starting point, while the Greedy Best-First-Search algorithm favours vertices that are closer to the goal. "),Object(o.b)("p",null,"A* search algorithm uses heuristics to determine the path it will take. The heuristic function provides an estimate of the minimum cost between the current vertex and the target vertex. The algorithm will combine the actual cost from the start vertex with the estimated cost to the target vertex. It will use the result to select the next vertex to evaluate."),Object(o.b)("h2",{id:"the-difference-from-other-shortest-path-algorithms"},"The difference from other shortest path algorithms"),Object(o.b)("p",null,"Unlike other traversal techniques, A",Object(o.b)("em",{parentName:"p"}," search algorithm has \u201cbrains\u201d. It is a really smart algorithm that uses heuristic methods to guide itself. A")," search algorithm is more efficient as its use of heuristics allows the algorithm to make a better choice about what path to take next. "),Object(o.b)("p",null,"While Dijkstra\u2019s algorithm will always find the shortest path between the starting vertex and every other vertex in the graph, A* search algorithm will find the shortest path between the starting vertex and target vertex."),Object(o.b)("p",null,"A* search algorithm is often used in pathfinding problems in video games, for finding the shortest path between a single pair of locations. It also finds use in parsing problems in Natural Language Processing (NPL)."),Object(o.b)("h2",{id:"pseudocode"},"Pseudocode"),Object(o.b)("p",null,"Before starting with the pseudocode, we need to explain the node structure. Each node has three attributes f, g, and h. Those attributes are parameters of the following equation:"),Object(o.b)("p",null,"f(n) = g(n) + h(n)\nWhere:\nf is cost of the transversal\ng is the actual cost of transversal from the starting node\nh is the estimate cost of transversal to the target node "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"INIT LIST openList\nINIT LIST closedList\nstartNode.f = 0\nADD startNode TO openList\nWHILE openList is not empty\n    currentNode = node with the least f value\n    REMOVE currentNode FROM penList\n    ADD currentNode TO closedList\n    IF currentNode = goal THEN\n        FINISHED\n    ENDIF\n    children = list of nodes adjacent to currentNode\n \n    FOR EACH child in children\n        IF child is in closedList\n            CONTINUE\n        ENDIF\n        child.g = currentNode.g + distance between child and current\n        child.h = distance from child to target\n        child.f = child.g + child.h\n        IF child.position is in the openList's nodes positions\n            IF the child.g is higher than the openList node's g\n                CONTINUE\n        ENDIF\n          ENDIF\n        ADD the child TO the openList\n    ENDFOR\nENDWHILE\n")),Object(o.b)("h2",{id:"usage-in-networkx"},"Usage in NetworkX"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"astar_path(G, source, target, heuristic=None, weight='weight')")),Object(o.b)("h3",{id:"method-input"},"Method input"),Object(o.b)("p",null,"The first input parameter of the method, G, is a NetworkX graph.\nThe second parameter, source, is the source node of the shortest path.\nThe third parameter, target, is the target node of the shortest path.\nThe fourth parameter, heuristic, is a function to evaluate the estimate of the distance from the a node to the target. The function takes two node arguments and must return a number.\nThe fifth parameter, weight, represents the edge attribute that should be used as the edge weight. If it\u2019s not specified, the weight of all edges will be 1. "),Object(o.b)("h3",{id:"method-output"},"Method output"),Object(o.b)("p",null,"The output of the method is a list of nodes."),Object(o.b)("h3",{id:"example"},"Example"),Object(o.b)("p",null,"A",Object(o.b)("em",{parentName:"p"}," search algorithm is implemented in Python\u2019s NetworkX library. Using A")," search algorithm in Python allows us to use custom methods and function as heuristics. In the following example, we designed the distance heuristic which calculates geometrical distances between the points. "),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-python"},'import networkx as nx\nimport matplotlib.pyplot as plt\n\ndef dist(a, b):\n    (x1, y1) = a\n    (x2, y2) = b\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\nG = nx.grid_graph(dim=[3, 3])  # nodes are two-tuples (x,y)\nnx.set_edge_attributes(G, {e: e[1][0] * 2 for e in G.edges()}, "cost")\npath = nx.astar_path(G, (0, 0), (2, 2), heuristic=dist, weight="cost")\nlength = nx.astar_path_length(G, (0, 0), (2, 2), heuristic=dist, weight="cost")\nprint(\u201cPath: \u201d + path)\nprint(\u201cPath length: \u201d + length)\n\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels = True, node_color="#f86e00")\nedge_labels = nx.get_edge_attributes(G, "cost")\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)\nplt.show()\n')),Object(o.b)("p",null,"The output is:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"Path: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\nPath length: 6\n")),Object(o.b)("p",null,"The first output represents the shortest path from point (0,0) to point (2,2). The second output is the length of the shortest path."))}c.isMDXComponent=!0},95:function(e,t,r){"use strict";r.d(t,"a",(function(){return d})),r.d(t,"b",(function(){return m}));var n=r(0),a=r.n(n);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function h(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=a.a.createContext({}),c=function(e){var t=a.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},d=function(e){var t=c(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,l=h(e,["components","mdxType","originalType","parentName"]),d=c(r),u=n,m=d["".concat(i,".").concat(u)]||d[u]||p[u]||o;return r?a.a.createElement(m,s(s({ref:t},l),{},{components:r})):a.a.createElement(m,s({ref:t},l))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var h in t)hasOwnProperty.call(t,h)&&(s[h]=t[h]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,r)}u.displayName="MDXCreateElement"}}]);