"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[968],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>p});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),h=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=h(r),p=n,m=d["".concat(l,".").concat(p)]||d[p]||c[p]||o;return r?a.createElement(m,s(s({ref:t},u),{},{components:r})):a.createElement(m,s({ref:t},u))}));function p(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var h=2;h<o;h++)s[h]=r[h];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},5162:(e,t,r)=>{r.d(t,{Z:()=>s});var a=r(7294),n=r(6010);const o="tabItem_Ymn6";function s(e){let{children:t,hidden:r,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,n.Z)(o,s),hidden:r},t)}},4866:(e,t,r)=>{r.d(t,{Z:()=>x});var a=r(7462),n=r(7294),o=r(6010),s=r(2466),i=r(6550),l=r(1980),h=r(7392),u=r(12);function c(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:r,attributes:a,default:n}}=e;return{value:t,label:r,attributes:a,default:n}}))}function d(e){const{values:t,children:r}=e;return(0,n.useMemo)((()=>{const e=t??c(r);return function(e){const t=(0,h.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function p(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:r}=e;const a=(0,i.k6)(),o=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,l._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function f(e){const{defaultValue:t,queryString:r=!1,groupId:a}=e,o=d(e),[s,i]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=r.find((e=>e.default))??r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[l,h]=m({queryString:r,groupId:a}),[c,f]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,u.Nk)(r);return[a,(0,n.useCallback)((e=>{r&&o.set(e)}),[r,o])]}({groupId:a}),g=(()=>{const e=l??c;return p({value:e,tabValues:o})?e:null})();(0,n.useLayoutEffect)((()=>{g&&i(g)}),[g]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),h(e),f(e)}),[h,f,o]),tabValues:o}}var g=r(2389);const b="tabList__CuJ",v="tabItem_LNqP";function w(e){let{className:t,block:r,selectedValue:i,selectValue:l,tabValues:h}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),d=e=>{const t=e.currentTarget,r=u.indexOf(t),a=h[r].value;a!==i&&(c(t),l(a))},p=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const r=u.indexOf(e.currentTarget)+1;t=u[r]??u[0];break}case"ArrowLeft":{const r=u.indexOf(e.currentTarget)-1;t=u[r]??u[u.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":r},t)},h.map((e=>{let{value:t,label:r,attributes:s}=e;return n.createElement("li",(0,a.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>u.push(e),onKeyDown:p,onClick:d},s,{className:(0,o.Z)("tabs__item",v,s?.className,{"tabs__item--active":i===t})}),r??t)})))}function k(e){let{lazy:t,children:r,selectedValue:a}=e;const o=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function y(e){const t=f(e);return n.createElement("div",{className:(0,o.Z)("tabs-container",b)},n.createElement(w,(0,a.Z)({},e,t)),n.createElement(k,(0,a.Z)({},e,t)))}function x(e){const t=(0,g.Z)();return n.createElement(y,(0,a.Z)({key:String(t)},e))}},5136:(e,t,r)=>{r.d(t,{Z:()=>o});var a=r(7294);const n={ctaButton:"ctaButton_fu4n",ctaBox:"ctaBox_gZT4"};function o(e){const{title:t,url:r}=e;return a.createElement("div",{className:n.ctaBox},a.createElement("a",{href:r,className:n.ctaButton,style:n},t))}},5832:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>h,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>d});var a=r(7462),n=(r(7294),r(3905)),o=r(5136),s=r(4866),i=r(5162);const l={id:"a-star-search",title:"A* search algorithm",sidebar_label:"A* search"},h=void 0,u={unversionedId:"algorithms/shortest-path/a-star-search",id:"algorithms/shortest-path/a-star-search",title:"A* search algorithm",description:"A\\* search algorithm is a graph traversal and path search algorithm often used in many fields of computer science. Starting from the starting node, it aims to find the path to the target node having the smallest cost.",source:"@site/docs/algorithms/shortest-path/a-star-search.md",sourceDirName:"algorithms/shortest-path",slug:"/algorithms/shortest-path/a-star-search",permalink:"/algorithms/shortest-path/a-star-search",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/shortest-path/a-star-search.md",tags:[],version:"current",frontMatter:{id:"a-star-search",title:"A* search algorithm",sidebar_label:"A* search"},sidebar:"networkx_guide",previous:{title:"Dijkstra",permalink:"/algorithms/shortest-path/dijkstra"},next:{title:"Floyd-Warshall",permalink:"/algorithms/shortest-path/floyd-warshall"}},c={},d=[{value:"How does it work?",id:"how-does-it-work",level:2},{value:"The difference from other shortest path algorithms",id:"the-difference-from-other-shortest-path-algorithms",level:2},{value:"Pseudocode",id:"pseudocode",level:2},{value:"Usage in NetworkX",id:"usage-in-networkx",level:2},{value:"Method input",id:"method-input",level:3},{value:"Method output",id:"method-output",level:3},{value:"Example",id:"example",level:3},{value:"Where to next?",id:"where-to-next",level:2}],p={toc:d};function m(e){let{components:t,...l}=e;return(0,n.kt)("wrapper",(0,a.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"A","*"," search algorithm is a graph traversal and path search algorithm often used in many fields of computer science. Starting from the starting node, it aims to find the path to the target node having the smallest cost."),(0,n.kt)("p",null,"It was made as a part of the Shakey project. The goal of the project was to build a mobile robot that could plan its own action. It yielded in the making of Shakey the Robot, the first general-purpose robot made in 1966. A* search algorithm was developed to help Shakey solve the pathfinding problems so it could move around."),(0,n.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,n.kt)("p",null,"A* search algorithm combines information from Dijkstra\u2019s algorithm and the Greedy Best-First-Search algorithm. Dijkstra\u2019s algorithm favours vertices that are closer to the starting point, while the Greedy Best-First-Search algorithm favours vertices that are closer to the goal. "),(0,n.kt)("p",null,"A* search algorithm uses heuristics to determine the path it will take. The heuristic function provides an estimate of the minimum cost between the current vertex and the target vertex. The algorithm will combine the actual cost from the start vertex with the estimated cost to the target vertex. It will use the result to select the next vertex to evaluate."),(0,n.kt)("h2",{id:"the-difference-from-other-shortest-path-algorithms"},"The difference from other shortest path algorithms"),(0,n.kt)("p",null,"The difference from other shortest path algorithms\nUnlike other traversal techniques, A","*"," search algorithm has \u201cbrains\u201d. It is a really smart algorithm that uses heuristic methods to guide itself. A","*"," search algorithm is more efficient as its use of heuristics allows the algorithm to make a better choice about what path to take next. "),(0,n.kt)("p",null,"While Dijkstra\u2019s algorithm will always find the shortest path between the starting vertex and every other vertex in the graph, A","*"," search algorithm will find the shortest path between the starting vertex and target vertex.  In a graph with a small number of nodes, Dijkstra\u2019s algorithm will suffice. However, in a real-life situation, we are dealing with the problem of an enormous number of combinations. For that, we need to use a \u201cguided\u201d algorithm that can decide the optimal route quickly and accurately. A","*"," search algorithm only performs steps if it seems promising and reasonable, unlike other shortest path algorithms. It runs toward the goal and doesn\u2019t consider any non-optimal steps if it doesn\u2019t have to consider them. "),(0,n.kt)("p",null,"A","*"," search algorithm is very useful for artificially intelligent systems such as machine learning and game development where characters navigate complex terrains and obstacles to reach players."),(0,n.kt)("h2",{id:"pseudocode"},"Pseudocode"),(0,n.kt)("p",null,"Before starting with the pseudocode, we need to explain the node structure. Each node has three attributes f, g, and h. Those attributes are parameters of the following equation:"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"f(n) = g(n) + h(n)")),(0,n.kt)("p",null,"Where: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"f is cost of the transversal"),(0,n.kt)("li",{parentName:"ul"},"g is the actual cost of transversal from the starting node"),(0,n.kt)("li",{parentName:"ul"},"h is the estimate cost of transversal to the target node ")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"INIT LIST openList\nINIT LIST closedList\nstartNode.f = 0\nADD startNode TO openList\nWHILE openList is not empty\n    currentNode = node with the least f value\n    REMOVE currentNode FROM penList\n    ADD currentNode TO closedList\n    IF currentNode = goal THEN\n        FINISHED\n    ENDIF\n    children = list of nodes adjacent to currentNode\n \n    FOR EACH child in children\n        IF child is in closedList\n            CONTINUE\n        ENDIF\n        child.g = currentNode.g + distance between child and current\n        child.h = distance from child to target\n        child.f = child.g + child.h\n        IF child.position is in the openList's nodes positions\n            IF the child.g is higher than the openList node's g\n                CONTINUE\n        ENDIF\n          ENDIF\n        ADD the child TO the openList\n    ENDFOR\nENDWHILE\n")),(0,n.kt)("h2",{id:"usage-in-networkx"},"Usage in NetworkX"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"astar_path(G, source, target, heuristic=None, weight='weight')")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Not fast enough?")," Find 100x faster algorithms ",(0,n.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=shortestpath%2Bastar&utm_content=findfasteralgorithms"},(0,n.kt)("strong",{parentName:"a"},"here")),"."),(0,n.kt)("h3",{id:"method-input"},"Method input"),(0,n.kt)("p",null,"The first input parameter of the method, G, is a NetworkX graph.\nThe second parameter, source, is the source node of the shortest path.\nThe third parameter, target, is the target node of the shortest path.\nThe fourth parameter, heuristic, is a function to evaluate the estimate of the distance from the a node to the target. The function takes two node arguments and must return a number.\nThe fifth parameter, weight, represents the edge attribute that should be used as the edge weight. If it\u2019s not specified, the weight of all edges will be 1. "),(0,n.kt)("h3",{id:"method-output"},"Method output"),(0,n.kt)("p",null,"The output of the method is a list of nodes."),(0,n.kt)("h3",{id:"example"},"Example"),(0,n.kt)("p",null,"Using A","*"," search algorithm in Python allows us to use custom methods and function as heuristics. In the following example, we designed the distance heuristic which calculates geometrical distances between the points. "),(0,n.kt)(s.Z,{groupId:"a_star",defaultValue:"code",values:[{label:"Python code",value:"code"},{label:"Output",value:"output"},{label:"Visualization",value:"visualization"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"code",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},'import networkx as nx\nimport matplotlib.pyplot as plt\n\n\ndef dist(a, b):\n    (x1, y1) = a\n    (x2, y2) = b\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\nG = nx.grid_graph(dim=[3, 3])  # nodes are two-tuples (x,y)\nnx.set_edge_attributes(G, {e: e[1][0] * 2 for e in G.edges()}, "cost")\npath = nx.astar_path(G, (0, 0), (2, 2), heuristic=dist, weight="cost")\nlength = nx.astar_path_length(G, (0, 0), (2, 2), heuristic=dist, weight="cost")\nprint("Path: ", path)\nprint("Path length: ", length)\n\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_color="#f86e00")\nedge_labels = nx.get_edge_attributes(G, "cost")\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)\nplt.show()\n'))),(0,n.kt)(i.Z,{value:"output",mdxType:"TabItem"},(0,n.kt)("p",null,"The first output represents the shortest path from point (0,0) to point (2,2). The second output is the length of the shortest path."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"Path: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\nPath length: 6\n"))),(0,n.kt)(i.Z,{value:"visualization",mdxType:"TabItem"},(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Astar matplotlib",src:r(6275).Z,width:"640",height:"480"})))),(0,n.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,n.kt)("p",null,"There are many graph algorithms libraries out there, with their own implementations of A","*"," search algorithm. NetworkX's algorithms are written in Python, and there are many other libraries that offer faster C++ implementations, such as ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},(0,n.kt)("strong",{parentName:"a"},"MAGE")),", a graph algorithms library developed by Memgraph team."),(0,n.kt)(o.Z,{title:"Memgraph for NetworkX developers",url:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=shortestpath%2Bastar&utm_content=ctabutton",mdxType:"CtaButton"}))}m.isMDXComponent=!0},6275:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/astar-matplotlib-f592903db52ed6923d4078c76f28f182.png"}}]);