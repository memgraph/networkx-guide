"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[36],{3905:(t,e,r)=>{r.d(e,{Zo:()=>p,kt:()=>m});var n=r(7294);function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function a(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function s(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){o(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function h(t,e){if(null==t)return{};var r,n,o=function(t,e){if(null==t)return{};var r,n,o={},a=Object.keys(t);for(n=0;n<a.length;n++)r=a[n],e.indexOf(r)>=0||(o[r]=t[r]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(n=0;n<a.length;n++)r=a[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(o[r]=t[r])}return o}var i=n.createContext({}),l=function(t){var e=n.useContext(i),r=e;return t&&(r="function"==typeof t?t(e):s(s({},e),t)),r},p=function(t){var e=l(t.components);return n.createElement(i.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},u=n.forwardRef((function(t,e){var r=t.components,o=t.mdxType,a=t.originalType,i=t.parentName,p=h(t,["components","mdxType","originalType","parentName"]),u=l(r),m=o,g=u["".concat(i,".").concat(m)]||u[m]||d[m]||a;return r?n.createElement(g,s(s({ref:e},p),{},{components:r})):n.createElement(g,s({ref:e},p))}));function m(t,e){var r=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=r.length,s=new Array(a);s[0]=u;var h={};for(var i in e)hasOwnProperty.call(e,i)&&(h[i]=e[i]);h.originalType=t,h.mdxType="string"==typeof t?t:o,s[1]=h;for(var l=2;l<a;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},1135:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>h,toc:()=>l});var n=r(7462),o=(r(7294),r(3905));const a={id:"dijkstra",title:"Dijkstra\u2019s algorithm",sidebar_label:"Dijkstra"},s=void 0,h={unversionedId:"algorithms/shortest-path/dijkstra",id:"algorithms/shortest-path/dijkstra",title:"Dijkstra\u2019s algorithm",description:"Dijkstra\u2019s algorithm finds the shortest path between nodes in a graph. With the algorithm, you can find the shortest path from a starting node to all the other nods in the graph.",source:"@site/docs/algorithms/shortest-path/dijkstra.md",sourceDirName:"algorithms/shortest-path",slug:"/algorithms/shortest-path/dijkstra",permalink:"/algorithms/shortest-path/dijkstra",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/shortest-path/dijkstra.md",tags:[],version:"current",frontMatter:{id:"dijkstra",title:"Dijkstra\u2019s algorithm",sidebar_label:"Dijkstra"},sidebar:"networkx_guide",previous:{title:"Shortest path",permalink:"/algorithms/shortest-path"},next:{title:"A* search",permalink:"/algorithms/shortest-path/a-star-search"}},i={},l=[{value:"How does it work?",id:"how-does-it-work",level:2},{value:"The difference from the other shortest path algorithms",id:"the-difference-from-the-other-shortest-path-algorithms",level:2},{value:"Pseudocode",id:"pseudocode",level:2},{value:"Usage in NetworkX",id:"usage-in-networkx",level:2},{value:"Method input",id:"method-input",level:3},{value:"Method output",id:"method-output",level:3},{value:"Example",id:"example",level:3}],p={toc:l};function d(t){let{components:e,...r}=t;return(0,o.kt)("wrapper",(0,n.Z)({},p,r,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Dijkstra\u2019s algorithm finds the shortest path between nodes in a graph. With the algorithm, you can find the shortest path from a starting node to all the other nods in the graph. "),(0,o.kt)("p",null,"The algorithm was designed by Dr Edsger Dijkstra, a Dutch computer scientist, in 1956. He designed the algorithm and implemented it for a slightly simplified transportation map of 64 cities in the Netherlands. In his own words, it was a 20-minute invention that is today one of the most important and well-known algorithms in the field of graph theory."),(0,o.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,o.kt)("p",null,"Dijkstra\u2019s algorithm starts at the chosen node (also known as the source node). The algorithm keeps track of the currently known shortest path from each node to the source node. It updates the path values if it finds a shorter path. When the algorithm finds the shortest path between the source node and another node, that node is marked as \u201cvisited\u201d and added to the path. This process continues until all of the nodes have been added to the path. The result of the algorithm is a path that connects the source node to all other nodes in the graph following the shortest path to each node.  "),(0,o.kt)("h2",{id:"the-difference-from-the-other-shortest-path-algorithms"},"The difference from the other shortest path algorithms"),(0,o.kt)("p",null,"Dijkstra\u2019s algorithm can only work on graphs that have positive values on the edges. The result of the algorithm is a structure called the minimum spanning tree - a tree-like structure that connects the source node to every other node in the graph following the shortest path to each node."),(0,o.kt)("h2",{id:"pseudocode"},"Pseudocode"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"INIT set of nodes Q\nINIT list dist\nINIT list prev\n\nFOR EACH node n in graph\n    SET dist[n] TO infinity\n    SET prev[n] TO unknown\n    ADD n TO Q\nENDFOR\ndist[source] = 0\n\nWHILE Q is not empty:\n    SET u TO node from Q with minimal dist[u]\n    REMOVE u FROM Q\n    FOR EACH neighbor node n of u\n        IF n in Q THEN\n            temp = dist[u] + length between u and n\n            IF temp < dist[v] THEN\n                dist[v] = temp\n                prev[v] = unknown\n            ENDIF\n        ENDIF\n    ENDFOR\nENDWHILE\n")),(0,o.kt)("h2",{id:"usage-in-networkx"},"Usage in NetworkX"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"shortest_path(G, source=None, target=None, weight=None, method='dijkstra')")),(0,o.kt)("h3",{id:"method-input"},"Method input"),(0,o.kt)("p",null,"The first input parameter of the method, G, is a NetworkX graph.\nThe second parameter, source, is the source node of the shortest path. If it\u2019s not specified, the method will compute the shortest path for all nodes.\nThe third parameter, target, is the target node of the shortest path. If it\u2019s not specified, the method will compute the shortest path to all possible nodes.\nThe fourth parameter, weight, represents the edge attribute that should be used as the edge weight. If it\u2019s not specified, the weight of all edges will be 1. "),(0,o.kt)("h3",{id:"method-output"},"Method output"),(0,o.kt)("p",null,"The output of the method is a list or dictionary with all the requested shortest paths. Paths are represented as lists of nodes. "),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("p",null,"In Python\u2019s library, NetworkX implements Dijkstra\u2019s algorithm as part of the shortest path algorithms. Insert the graph from Figure 1 in NetworkX (see Appendix A) before you start the example program."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python="},"import networkx as nx\n\nedges = [(1,2, {'weight':4}),\n        (1,3,{'weight':2}),\n        (2,3,{'weight':1}),\n        (2,4, {'weight':5}),\n        (3,4, {'weight':8}),\n        (3,5, {'weight':10}),\n        (4,5,{'weight':2}),\n        (4,6,{'weight':8}),\n        (5,6,{'weight':5})]\nedge_labels = {(1,2):4, (1,3):2, (2,3):1, (2,4):5, (3,4):8, (3,5):10, (4,5):2, (4,6):8, (5,6):5}\n   \n        \nG = nx.Graph()\nfor i in range(1,7):\n    G.add_node(i)\nG.add_edges_from(edges)\n\npos = nx.planar_layout(G)\n\n# This will give us all the shortest paths from node 1 using the weights from the edges. \np1 = nx.shortest_path(G, source=1, weight='weight')\n\n# This will give us the shortest path from node 1 to node 6.\np1to6 = nx.shortest_path(G, source=1, target=6, weight='weight')\n\n# This will give us the length of the shortest path from node 1 to node 6.\nlength = nx.shortest_path_length(G, source=1, target=6, weight='weight')\n\nprint(\u201cAll shortest paths from 1: \u201c + p1)\nprint(\u201cShortest path from 1 to 6: \u201c + p1to6)\nprint(\u201cLength of the shortest path: \u201d + length)\n")),(0,o.kt)("p",null,"The output is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"All paths from 1: {1: [1], 2: [1, 3, 2], 3: [1, 3], 4: [1, 3, 2, 4], 5: [1, 3, 2, 4, 5], 6: [1, 3, 2, 4, 5, 6]}\nShortest path from 1 to 6: [1, 3, 2, 4, 5, 6] \nLength of the shortest path: 15\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Not fast enough?")," Find 100x faster algorithms ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=algorithms%2Bdijkstra&utm_content=findfasteralgorithms"},(0,o.kt)("strong",{parentName:"a"},"here")),"."))}d.isMDXComponent=!0}}]);