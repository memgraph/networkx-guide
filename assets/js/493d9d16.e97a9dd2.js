"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[36],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>c});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),h=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=h(r),c=a,m=p["".concat(l,".").concat(c)]||p[c]||d[c]||o;return r?n.createElement(m,s(s({ref:t},u),{},{components:r})):n.createElement(m,s({ref:t},u))}));function c(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var h=2;h<o;h++)s[h]=r[h];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5162:(e,t,r)=>{r.d(t,{Z:()=>s});var n=r(7294),a=r(6010);const o="tabItem_Ymn6";function s(e){let{children:t,hidden:r,className:s}=e;return n.createElement("div",{role:"tabpanel",className:(0,a.Z)(o,s),hidden:r},t)}},4866:(e,t,r)=>{r.d(t,{Z:()=>T});var n=r(7462),a=r(7294),o=r(6010),s=r(2466),i=r(6550),l=r(1980),h=r(7392),u=r(12);function d(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:r,attributes:n,default:a}}=e;return{value:t,label:r,attributes:n,default:a}}))}function p(e){const{values:t,children:r}=e;return(0,a.useMemo)((()=>{const e=t??d(r);return function(e){const t=(0,h.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function c(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:r}=e;const n=(0,i.k6)(),o=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,l._X)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(n.location.search);t.set(o,e),n.replace({...n.location,search:t.toString()})}),[o,n])]}function f(e){const{defaultValue:t,queryString:r=!1,groupId:n}=e,o=p(e),[s,i]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=r.find((e=>e.default))??r[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[l,h]=m({queryString:r,groupId:n}),[d,f]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,o]=(0,u.Nk)(r);return[n,(0,a.useCallback)((e=>{r&&o.set(e)}),[r,o])]}({groupId:n}),g=(()=>{const e=l??d;return c({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{g&&i(g)}),[g]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!c({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),h(e),f(e)}),[h,f,o]),tabValues:o}}var g=r(2389);const k="tabList__CuJ",w="tabItem_LNqP";function b(e){let{className:t,block:r,selectedValue:i,selectValue:l,tabValues:h}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),p=e=>{const t=e.currentTarget,r=u.indexOf(t),n=h[r].value;n!==i&&(d(t),l(n))},c=e=>{let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const r=u.indexOf(e.currentTarget)+1;t=u[r]??u[0];break}case"ArrowLeft":{const r=u.indexOf(e.currentTarget)-1;t=u[r]??u[u.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":r},t)},h.map((e=>{let{value:t,label:r,attributes:s}=e;return a.createElement("li",(0,n.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>u.push(e),onKeyDown:c,onClick:p},s,{className:(0,o.Z)("tabs__item",w,s?.className,{"tabs__item--active":i===t})}),r??t)})))}function v(e){let{lazy:t,children:r,selectedValue:n}=e;const o=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===n));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function y(e){const t=f(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",k)},a.createElement(b,(0,n.Z)({},e,t)),a.createElement(v,(0,n.Z)({},e,t)))}function T(e){const t=(0,g.Z)();return a.createElement(y,(0,n.Z)({key:String(t)},e))}},5136:(e,t,r)=>{r.d(t,{Z:()=>o});var n=r(7294);const a={ctaButton:"ctaButton_fu4n",ctaBox:"ctaBox_gZT4"};function o(e){const{title:t,url:r}=e;return n.createElement("div",{className:a.ctaBox},n.createElement("a",{href:r,className:a.ctaButton,style:a},t))}},1135:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>h,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>p});var n=r(7462),a=(r(7294),r(3905)),o=r(5136),s=r(4866),i=r(5162);const l={id:"dijkstra",title:"Dijkstra\u2019s algorithm",sidebar_label:"Dijkstra"},h=void 0,u={unversionedId:"algorithms/shortest-path/dijkstra",id:"algorithms/shortest-path/dijkstra",title:"Dijkstra\u2019s algorithm",description:"Dijkstra\u2019s algorithm finds the shortest path between nodes in a graph. With the algorithm, you can find the shortest path from a starting node to all the other nods in the graph.",source:"@site/docs/algorithms/shortest-path/dijkstra.md",sourceDirName:"algorithms/shortest-path",slug:"/algorithms/shortest-path/dijkstra",permalink:"/algorithms/shortest-path/dijkstra",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/shortest-path/dijkstra.md",tags:[],version:"current",frontMatter:{id:"dijkstra",title:"Dijkstra\u2019s algorithm",sidebar_label:"Dijkstra"},sidebar:"networkx_guide",previous:{title:"Shortest path algorithms overview",permalink:"/algorithms/shortest-path"},next:{title:"A* search",permalink:"/algorithms/shortest-path/a-star-search"}},d={},p=[{value:"How does it work?",id:"how-does-it-work",level:2},{value:"The difference from the other shortest path algorithms",id:"the-difference-from-the-other-shortest-path-algorithms",level:2},{value:"Pseudocode",id:"pseudocode",level:2},{value:"Usage in NetworkX",id:"usage-in-networkx",level:2},{value:"Method input",id:"method-input",level:3},{value:"Method output",id:"method-output",level:3},{value:"Example",id:"example",level:3},{value:"Where to next?",id:"where-to-next",level:2}],c={toc:p};function m(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Dijkstra\u2019s algorithm finds the shortest path between nodes in a graph. With the algorithm, you can find the shortest path from a starting node to all the other nods in the graph. "),(0,a.kt)("p",null,"The algorithm was designed by Dr Edsger Dijkstra, a Dutch computer scientist, in 1956. He designed the algorithm and implemented it for a slightly simplified transportation map of 64 cities in the Netherlands. In his own words, it was a 20-minute invention that is today one of the most important and well-known algorithms in the field of graph theory."),(0,a.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,a.kt)("p",null,"Dijkstra\u2019s algorithm starts at the chosen node (also known as the source node). The algorithm keeps track of the currently known shortest path from each node to the source node. It updates the path values if it finds a shorter path. When the algorithm finds the shortest path between the source node and another node, that node is marked as \u201cvisited\u201d and added to the path. This process continues until all of the nodes have been added to the path. The result of the algorithm is a path that connects the source node to all other nodes in the graph following the shortest path to each node.  "),(0,a.kt)("h2",{id:"the-difference-from-the-other-shortest-path-algorithms"},"The difference from the other shortest path algorithms"),(0,a.kt)("p",null,"Dijkstra\u2019s algorithm can only work on graphs that have positive values on the edges. The result of the algorithm is a structure called the minimum spanning tree - a tree-like structure that connects the source node to every other node in the graph following the shortest path to each node."),(0,a.kt)("h2",{id:"pseudocode"},"Pseudocode"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"INIT set of nodes Q\nINIT list dist\nINIT list prev\n\nFOR EACH node n in graph\n    SET dist[n] TO infinity\n    SET prev[n] TO unknown\n    ADD n TO Q\nENDFOR\ndist[source] = 0\n\nWHILE Q is not empty:\n    SET u TO node from Q with minimal dist[u]\n    REMOVE u FROM Q\n    FOR EACH neighbor node n of u\n        IF n in Q THEN\n            temp = dist[u] + length between u and n\n            IF temp < dist[v] THEN\n                dist[v] = temp\n                prev[v] = unknown\n            ENDIF\n        ENDIF\n    ENDFOR\nENDWHILE\n")),(0,a.kt)("h2",{id:"usage-in-networkx"},"Usage in NetworkX"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"shortest_path(G, source=None, target=None, weight=None, method='dijkstra')")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Not fast enough?")," Find 100x faster algorithms ",(0,a.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=shortestpath%2Bdijkstra&utm_content=findfasteralgorithms"},(0,a.kt)("strong",{parentName:"a"},"here")),"."),(0,a.kt)("h3",{id:"method-input"},"Method input"),(0,a.kt)("p",null,"The first input parameter of the method, G, is a NetworkX graph.\nThe second parameter, source, is the source node of the shortest path. If it\u2019s not specified, the method will compute the shortest path for all nodes.\nThe third parameter, target, is the target node of the shortest path. If it\u2019s not specified, the method will compute the shortest path to all possible nodes.\nThe fourth parameter, weight, represents the edge attribute that should be used as the edge weight. If it\u2019s not specified, the weight of all edges will be 1. "),(0,a.kt)("h3",{id:"method-output"},"Method output"),(0,a.kt)("p",null,"The output of the method is a list or dictionary with all the requested shortest paths. Paths are represented as lists of nodes. "),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)(s.Z,{groupId:"dijkstra",defaultValue:"code",values:[{label:"Python code",value:"code"},{label:"Output",value:"output"}],mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"code",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'import networkx as nx\n\nedges = [\n    (1, 2, {"weight": 4}),\n    (1, 3, {"weight": 2}),\n    (2, 3, {"weight": 1}),\n    (2, 4, {"weight": 5}),\n    (3, 4, {"weight": 8}),\n    (3, 5, {"weight": 10}),\n    (4, 5, {"weight": 2}),\n    (4, 6, {"weight": 8}),\n    (5, 6, {"weight": 5}),\n]\nedge_labels = {\n    (1, 2): 4,\n    (1, 3): 2,\n    (2, 3): 1,\n    (2, 4): 5,\n    (3, 4): 8,\n    (3, 5): 10,\n    (4, 5): 2,\n    (4, 6): 8,\n    (5, 6): 5,\n}\n\n\nG = nx.Graph()\nfor i in range(1, 7):\n    G.add_node(i)\nG.add_edges_from(edges)\n\npos = nx.planar_layout(G)\n\n# This will give us all the shortest paths from node 1 using the weights from the edges.\np1 = nx.shortest_path(G, source=1, weight="weight")\n\n# This will give us the shortest path from node 1 to node 6.\np1to6 = nx.shortest_path(G, source=1, target=6, weight="weight")\n\n# This will give us the length of the shortest path from node 1 to node 6.\nlength = nx.shortest_path_length(G, source=1, target=6, weight="weight")\n\nprint("All shortest paths from 1: ", p1)\nprint("Shortest path from 1 to 6: ", p1to6)\nprint("Length of the shortest path: ", length)\n'))),(0,a.kt)(i.Z,{value:"output",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"All paths from 1: {1: [1], 2: [1, 3, 2], 3: [1, 3], 4: [1, 3, 2, 4], 5: [1, 3, 2, 4, 5], 6: [1, 3, 2, 4, 5, 6]}\nShortest path from 1 to 6: [1, 3, 2, 4, 5, 6] \nLength of the shortest path: 15\n")))),(0,a.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,a.kt)("p",null,"There are many graph algorithms libraries out there, with their own implementations of Dijkstra's algorithm. NetworkX's algorithms are written in Python, and there are many other libraries that offer faster C++ implementations, such as ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},(0,a.kt)("strong",{parentName:"a"},"MAGE")),", a graph algorithms library developed by Memgraph team."),(0,a.kt)(o.Z,{title:"Memgraph for NetworkX developers",url:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=shortestpath%2Bdijkstra&utm_content=ctabutton",mdxType:"CtaButton"}))}m.isMDXComponent=!0}}]);