"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[770],{3905:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>h});var a=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,r=function(e,t){if(null==e)return{};var o,a,r={},n=Object.keys(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var o=e.components,r=e.mdxType,n=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(o),h=r,g=m["".concat(l,".").concat(h)]||m[h]||c[h]||n;return o?a.createElement(g,i(i({ref:t},u),{},{components:o})):a.createElement(g,i({ref:t},u))}));function h(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=o.length,i=new Array(n);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<n;p++)i[p]=o[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,o)}m.displayName="MDXCreateElement"},5136:(e,t,o)=>{o.d(t,{Z:()=>n});var a=o(7294);const r={ctaButton:"ctaButton_fu4n",ctaBox:"ctaBox_gZT4"};function n(e){const{title:t,url:o}=e;return a.createElement("div",{className:r.ctaBox},a.createElement("a",{href:o,className:r.ctaButton,style:r},t))}},6819:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=o(7462),r=(o(7294),o(3905)),n=o(5136);const i={title:"Biggest challenges with NetworkX",sidebar_label:"Biggest challenges"},s=void 0,l={unversionedId:"biggest-challenges",id:"biggest-challenges",title:"Biggest challenges with NetworkX",description:"If you have been using NetworkX for one of your projects, you\u2019ve probably noticed some of its limitations. Here you can find the biggest challenges you may stumble upon when working with NetworkX.",source:"@site/docs/biggest-challenges.md",sourceDirName:".",slug:"/biggest-challenges",permalink:"/biggest-challenges",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/biggest-challenges.md",tags:[],version:"current",frontMatter:{title:"Biggest challenges with NetworkX",sidebar_label:"Biggest challenges"},sidebar:"networkx_guide",previous:{title:"Weakly connected components (Union find)",permalink:"/algorithms/components/weakly-connected-components"},next:{title:"Other resources",permalink:"/other-resources"}},p={},u=[{value:"Dataset load time",id:"dataset-load-time",level:2},{value:"Scaling and persistence",id:"scaling-and-persistence",level:2},{value:"Quick and easy visualizations",id:"quick-and-easy-visualizations",level:2},{value:"Smooth application deployment",id:"smooth-application-deployment",level:2},{value:"How to overcome these challenges?",id:"how-to-overcome-these-challenges",level:2}],c={toc:u};function m(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If you have been using NetworkX for one of your projects, you\u2019ve probably noticed some of its limitations. Here you can find the ",(0,r.kt)("strong",{parentName:"p"},"biggest challenges")," you may stumble upon when working with NetworkX. "),(0,r.kt)("h2",{id:"dataset-load-time"},"Dataset load time"),(0,r.kt)("p",null,"Each time you want to change something in the dataset or run another algorithm, you have to load the dataset all over again. This repetitive loading wastes time and slows down the development process, especially for large datasets. If you have run into these kind of issues, check out our ",(0,r.kt)("a",{parentName:"p",href:"/faq#scaling-and-persistence"},(0,r.kt)("strong",{parentName:"a"},"FAQ"))," to help you solve your loading time."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"To avoid long load time, it's best to have a persistent storage solution. Since the objects stored in NetworkX are graphs, it makes sense to use a graph database as a storage solution. Memgraph is an open source in-memory graph database which ensures data durability and keeps your data in place for quick analytics. If you want to still use familiar NetworkX library, you can do it out of the box. Read how to on ",(0,r.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=biggestchallenges&utm_content=datasetloadtime"},(0,r.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website.")),(0,r.kt)("h2",{id:"scaling-and-persistence"},"Scaling and persistence"),(0,r.kt)("p",null,"NetworkX stores data in-memory in instantiated Python objects - Graph, DiGraph, MultiGraph, or MultiDiGraph. So NetworkX can actually give results of graph algorithms on smaller-scale graphs pretty fast. But, each time you need to change something in the database or run another algorithm, you have to reload the dataset into the appropriate Python object. There are a couple of solutions to store the data somewhere else, including exporting and importing those Python objects to different formats or using on-disk storage solutions, but that means more software you need to figure out, which slows down the development process significantly. Read more about those solutions on our ",(0,r.kt)("a",{parentName:"p",href:"/faq#scaling-and-persistence"},(0,r.kt)("strong",{parentName:"a"},"FAQ")),". "),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you like using NetworkX as a graph analytic tool required for your project but often need to reach for other tools, remember that Memgraph can speed up your development by being persistent in-memory data storage. You still get to use the NetworkX algorithms you are used to or explore other, more efficient, and dynamic algorithms. If default and implemented algorithms and procedures do not cover your use case, extend the Cypher query language with custom procedures. Check out the ",(0,r.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=biggestchallenges&utm_content=textlink"},(0,r.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website to learn more about this integration.")),(0,r.kt)("h2",{id:"quick-and-easy-visualizations"},"Quick and easy visualizations"),(0,r.kt)("p",null,"After running the queries, you probably want to explore the results by playing around with their visualization and share exciting insights you come across. As you probably know, NetworkX is not primarily a graph drawing package, so it doesn\u2019t offer much to create visually pleasing and interactive graphs. Also, NetworkX cannot handle visualizations of large graphs, so you need to reach out for another drawing library and learn how to use it. Even when those libraries are better than NetworkX alone, they still have limitations regarding zooming and interacting with nodes and relationships, such as dragging and clicking. Read more about the common issues at out ",(0,r.kt)("a",{parentName:"p",href:"/faq#graph-drawing"},"FAQ section"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"A visualization tool is a part of the Memgraph package, so there is no more need to explore other solutions. Feel free to shape the graph results so they reflect the insights you discovered in the best possible way. ",(0,r.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=biggestchallenges&utm_content=learnmore"},(0,r.kt)("strong",{parentName:"a"},"Learn how to use Memgraph with NetworkX"))," to get the most out of your data.")),(0,r.kt)("h2",{id:"smooth-application-deployment"},"Smooth application deployment"),(0,r.kt)("p",null,"NetworkX is not a database, so of course, it is missing other features that come in handy when you are deploying your application. For example, with a graph database, you can always do ad-hoc graph querying. If you plan to use your project in production, you need to find an appropriate permanent storage solution and additional graph analytics capabilities. "),(0,r.kt)("p",null,"The beginning of every NetworkX project includes data import. If you are importing data from different sources, your code is probably snowballing with every additional source. Things are getting messy, and every time you change something in the code, you have to pull the data from all those different sources all over again. The project gets harder to maintain, and your time gets unnecessarily wasted on pulling the data rather than on the actual analysis."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Avoid all of the boilerplate code and smoothly deploy applications by using Memgraph, an open-source in-memory graph database, on which you can perform graph analytics using NetworkX you are familiar with, both on static and streaming datasets. ",(0,r.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=biggestchallenges&utm_content=checkoutresources"},(0,r.kt)("strong",{parentName:"a"},"Check out resources"))," on how to use Memgraph with NetworkX.")),(0,r.kt)("h2",{id:"how-to-overcome-these-challenges"},"How to overcome these challenges?"),(0,r.kt)("p",null,"Memgraph is a drop-in replacement for a huge part of the boilerplate code in the NetworkX project. It can work with streaming or static datasets and it offers easy integration of any NetworkX code. Although it is in-memory, Memgraph still persists your data, meaning your dataset doesn\u2019t have to be loaded on each run. It\u2019s enough to load it once and then query, analyze and change it. You can explore parts of the graph you need and deliver an analysis of the dataset. "),(0,r.kt)(n.Z,{title:"Memgraph for NetworkX developers",url:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=biggestchallenges&utm_content=overcomechallenges",mdxType:"CtaButton"}))}m.isMDXComponent=!0}}]);