"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[961],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return n?o.createElement(h,l(l({ref:t},u),{},{components:n})):o.createElement(h,l({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var c=2;c<r;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>l});var o=n(7294),a=n(6010);const r="tabItem_Ymn6";function l(e){let{children:t,hidden:n,className:l}=e;return o.createElement("div",{role:"tabpanel",className:(0,a.Z)(r,l),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>x});var o=n(7462),a=n(7294),r=n(6010),l=n(2466),i=n(6550),s=n(1980),c=n(7392),u=n(12);function p(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:o,default:a}}=e;return{value:t,label:n,attributes:o,default:a}}))}function d(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const o=(0,i.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(r),(0,a.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(o.location.search);t.set(r,e),o.replace({...o.location,search:t.toString()})}),[r,o])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:o}=e,r=d(e),[l,i]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const o=n.find((e=>e.default))??n[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:t,tabValues:r}))),[s,c]=h({queryString:n,groupId:o}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,r]=(0,u.Nk)(n);return[o,(0,a.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:o}),g=(()=>{const e=s??p;return m({value:e,tabValues:r})?e:null})();(0,a.useLayoutEffect)((()=>{g&&i(g)}),[g]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),c(e),f(e)}),[c,f,r]),tabValues:r}}var g=n(2389);const b="tabList__CuJ",k="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:i,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),d=e=>{const t=e.currentTarget,n=u.indexOf(t),o=c[n].value;o!==i&&(p(t),s(o))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:l}=e;return a.createElement("li",(0,o.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:d},l,{className:(0,r.Z)("tabs__item",k,l?.className,{"tabs__item--active":i===t})}),n??t)})))}function v(e){let{lazy:t,children:n,selectedValue:o}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===o));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==o}))))}function w(e){const t=f(e);return a.createElement("div",{className:(0,r.Z)("tabs-container",b)},a.createElement(y,(0,o.Z)({},e,t)),a.createElement(v,(0,o.Z)({},e,t)))}function x(e){const t=(0,g.Z)();return a.createElement(w,(0,o.Z)({key:String(t)},e))}},5136:(e,t,n)=>{n.d(t,{Z:()=>r});var o=n(7294);const a={ctaButton:"ctaButton_fu4n",ctaBox:"ctaBox_gZT4"};function r(e){const{title:t,url:n}=e;return o.createElement("div",{className:a.ctaBox},o.createElement("a",{href:n,className:a.ctaButton,style:a},t))}},7904:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>d});var o=n(7462),a=(n(7294),n(3905)),r=n(5136),l=n(4866),i=n(5162);const s={id:"weakly-connected-components",title:"Weakly connected components algorithm (Union find)",sidebar_label:"Weakly connected components (Union find)"},c=void 0,u={unversionedId:"algorithms/components/weakly-connected-components",id:"algorithms/components/weakly-connected-components",title:"Weakly connected components algorithm (Union find)",description:"A weakly connected component is a subgraph that is unreachable from other nodes/vertices of a graph or subgraph. The algorithm was described by A. Galler and Michael J. in 1964 and specific implementations either utilize breadth-first search or depth-first search to find the graph components.",source:"@site/docs/algorithms/components/weakly-connected-components.md",sourceDirName:"algorithms/components",slug:"/algorithms/components/weakly-connected-components",permalink:"/algorithms/components/weakly-connected-components",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/components/weakly-connected-components.md",tags:[],version:"current",frontMatter:{id:"weakly-connected-components",title:"Weakly connected components algorithm (Union find)",sidebar_label:"Weakly connected components (Union find)"},sidebar:"networkx_guide",previous:{title:"Girvan-Newman",permalink:"/algorithms/community-detection/girvan-newman"},next:{title:"Biggest challenges",permalink:"/biggest-challenges"}},p={},d=[{value:"Practical Applications",id:"practical-applications",level:2},{value:"Pseudocode",id:"pseudocode",level:2},{value:"Usage in NetworkX",id:"usage-in-networkx",level:2},{value:"Method input",id:"method-input",level:3},{value:"Method output",id:"method-output",level:3},{value:"Example",id:"example",level:3},{value:"Where to next?",id:"where-to-next",level:2}],m={toc:d};function h(e){let{components:t,...s}=e;return(0,a.kt)("wrapper",(0,o.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A weakly connected component is a subgraph that is unreachable from other nodes/vertices of a graph or subgraph. The algorithm was described by A. Galler and Michael J. in 1964 and specific implementations either utilize breadth-first search or depth-first search to find the graph components.\nHow does it work?\nThe Weakly Connected Components algorithm (WCC), also known as Union Find, searches for distinct sets of connected nodes in a graph. All nodes in such a set are reachable from any other node in the same set.\nWhile the Strongly Connected Components algorithm (SCC) requires nodes to be reachable in both directions, WCC only requires nodes to be reachable in one direction. Both algorithms are used for network structure analysis."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"WCC-example",src:n(1918).Z,width:"1124",height:"889"})),(0,a.kt)("p",null,"For example, in the graph above, you can see three weakly connected components. Nodes from the subgraph {A, B, C} aren\u2019t connected to any other nodes in the graph and therefore must be a separate component."),(0,a.kt)("h2",{id:"practical-applications"},"Practical Applications"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The Weakly Connected Component algorithm is mostly used for graph pre-processing. Many graph algorithms require networks to be fully connected without distinct components. Union find can be used to find and potentially eliminate such components."),(0,a.kt)("li",{parentName:"ul"},"WCC can be used for basic community detection use cases where distinct disconnected groups are expected."),(0,a.kt)("li",{parentName:"ul"},"Some social networks can utilize weakly connected components for recommendation generating purposes.")),(0,a.kt)("h2",{id:"pseudocode"},"Pseudocode"),(0,a.kt)("p",null,"Start by labeling all nodes as unvisited. Then, iterate over the nodes in any order. For each node, if it wasn\u2019t visited, run BFS from that node and add all reachable nodes as the same component. Add them to the list of visited nodes as well. If the node was already visited, skip it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"visited_nodes = []\ncomponents = []\nFOR EACH node n in graph\n    IF n is not in visited_nodes THEN\n        connected_nodes = BFS(v)\n        ADD connected_nodes TO visited_nodes\n        ADD connected_nodes TO component\n    ENDIF\nENDFOR\n")),(0,a.kt)("h2",{id:"usage-in-networkx"},"Usage in NetworkX"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"weakly_connected_components(G)\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Not fast enough?")," Find 100x faster algorithms ",(0,a.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=components%2Bweaklyconnectedcomponents&utm_content=findfasteralgorithms"},(0,a.kt)("strong",{parentName:"a"},"here")),"."),(0,a.kt)("h3",{id:"method-input"},"Method input"),(0,a.kt)("p",null,"The input parameter of the method, ",(0,a.kt)("inlineCode",{parentName:"p"},"G"),", is a directed graph."),(0,a.kt)("h3",{id:"method-output"},"Method output"),(0,a.kt)("p",null,"The output of the method is a generator of sets. Each set contains the nodes of one weakly connected component."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)(l.Z,{groupId:"wcc",defaultValue:"code",values:[{label:"Python code",value:"code"},{label:"Output",value:"output"},{label:"Visualization",value:"visualization"}],mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"code",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import matplotlib.pyplot as plt\nimport networkx as nx\nfrom networkx.algorithms.components import weakly_connected_components\n\nG = nx.path_graph(4, create_using=nx.DiGraph())\nnx.add_path(G, [10, 11, 12])\n\ncommunities = weakly_connected_components(G)\n\nnode_groups = []\nfor com in communities:\n  node_groups.append(list(com))\n\nprint(node_groups)\n\ncolor_map = []\nfor node in G:\n    if node in node_groups[0]:\n        color_map.append('orange')\n    else: \n        color_map.append('red')  \n\nnx.draw(G, node_color=color_map, with_labels=True)\nplt.show()\n"))),(0,a.kt)(i.Z,{value:"output",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"[[0, 1, 2, 3], [10, 11, 12]]\n"))),(0,a.kt)(i.Z,{value:"visualization",mdxType:"TabItem"},(0,a.kt)("p",null,"The network has two weakly connected components:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"WCC matplotlib",src:n(8729).Z,width:"640",height:"480"})))),(0,a.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,a.kt)("p",null,"There are many graph algorithms libraries out there, with their own implementations of weakly connected components algorithm. NetworkX's algorithms are written in Python, and there are many other libraries that offer faster C++ implementations, such as ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},(0,a.kt)("strong",{parentName:"a"},"MAGE")),", a graph algorithms library developed by Memgraph team."),(0,a.kt)(r.Z,{title:"Memgraph for NetworkX developers",url:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=components%2Bweaklyconnectedcomponents&utm_content=ctabutton",mdxType:"CtaButton"}))}h.isMDXComponent=!0},1918:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/wcc-example-0db447c402ad732b74567c79ae103ba1.jpg"},8729:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/wcc-matplotlib-9d37b46220fe1db6aa79f8d922df2db6.png"}}]);