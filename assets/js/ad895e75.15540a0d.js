"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[288],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>d});var a=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,o=function(e,t){if(null==e)return{};var r,a,o={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=a.createContext({}),h=function(e){var t=a.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},l=function(e){var t=h(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,o=e.mdxType,n=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),m=h(r),d=o,c=m["".concat(p,".").concat(d)]||m[d]||u[d]||n;return r?a.createElement(c,s(s({ref:t},l),{},{components:r})):a.createElement(c,s({ref:t},l))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=r.length,s=new Array(n);s[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var h=2;h<n;h++)s[h]=r[h];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},5136:(e,t,r)=>{r.d(t,{Z:()=>n});var a=r(7294);const o={ctaButton:"ctaButton_fu4n",ctaBox:"ctaBox_gZT4"};function n(e){const{title:t,url:r}=e;return a.createElement("div",{className:o.ctaBox},a.createElement("a",{href:r,className:o.ctaButton,style:o},t))}},3581:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>l});var a=r(7462),o=(r(7294),r(3905)),n=r(5136);const s={id:"faq",title:"Frequently asked questions",sidebar_label:"FAQ"},i=void 0,p={unversionedId:"faq",id:"faq",title:"Frequently asked questions",description:"Here is the list of most common questions and answers from different developer communities.",source:"@site/docs/FAQ.md",sourceDirName:".",slug:"/faq",permalink:"/faq",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/FAQ.md",tags:[],version:"current",frontMatter:{id:"faq",title:"Frequently asked questions",sidebar_label:"FAQ"},sidebar:"networkx_guide",previous:{title:"Other resources",permalink:"/other-resources"}},h={},l=[{value:"Scaling and persistence",id:"scaling-and-persistence",level:2},{value:"Is there a way to store the graph object so that each time I run my script, NetworkX reads that file and loads the graph?",id:"store-huge-graph",level:3},{value:"Is it possible to use NetworkX along with some kind of persistent storage?",id:"persistent-storage",level:3},{value:"Where does NetworkX store graph info?",id:"store-graph-info",level:3},{value:"Why does NetworkX&#39;s Python implementation affects its performance?",id:"python-performance",level:3},{value:"Is it possible to load a graph with millions of nodes and edges with NetworkX?",id:"load-graph",level:3},{value:"What is better to use? NetworkX or a graph database?",id:"networkx-vs-graph-db",level:3},{value:"Is there a way not to load one of the NetworkX generated graph each time?",id:"generated-graph",level:3},{value:"Graph drawing",id:"graph-drawing",level:2},{value:"Are there any other solutions to draw my NetworkX graphs with?",id:"drawing-solutions",level:3},{value:"Why is the drawing of my NetworkX graph with about 50000 nodes and edges taking forever?",id:"drawing-large-graph",level:3},{value:"Where to next?",id:"where-to-next",level:2}],u={toc:l};function m(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Here is the list of most common questions and answers from different developer communities. "),(0,o.kt)("h2",{id:"scaling-and-persistence"},"Scaling and persistence"),(0,o.kt)("h3",{id:"store-huge-graph"},"Is there a way to store the graph object so that each time I run my script, NetworkX reads that file and loads the graph?"),(0,o.kt)("p",null,"Let's say you have a huge graph in NetworkX and it takes a lot to create this graph each time I execute the script. This means you have to wait a lot each time to actually analyze the dataset. To store the graph, you can use different methods of writing the graph to a file, but the best option would be to use ",(0,o.kt)("inlineCode",{parentName:"p"},"write_gpickle")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"read_gpickle")," procedures from the ",(0,o.kt)("inlineCode",{parentName:"p"},"pickle")," library."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import pickle\n\n# save graph object to graph.pickle file\npickle.dump(G, open('graph.pickle', 'wb'))\n\n# load graph object from graph.pickle file\nG = pickle.load(open('graph.pickle', 'rb'))\n")),(0,o.kt)("p",null,"If this is still not fast enough, consider switching to a persistent graph database solution with NetworxX algorithms, such as Memgraph. Read more about it at ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=storehugegraph"},(0,o.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website."),(0,o.kt)("h3",{id:"persistent-storage"},"Is it possible to use NetworkX along with some kind of persistent storage?"),(0,o.kt)("p",null,"It is possible to use NetworkX with different kinds of persistent storage. The best kind of storage to use is a graph database, since the data there is stored in a form of nodes and relationships, just like in NetworkX. It will be much easier to obtain the data you want to analyze from a graph, rather than relational database. There are different graph solutions out there, such as Memgraph, an open source persistent in-memory graph database. To learn more about it, head over to the ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=persistentstorage"},(0,o.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website."),(0,o.kt)("h3",{id:"store-graph-info"},"Where does NetworkX store graph info?"),(0,o.kt)("p",null,"What if you want to access the graph that you created with NetworkX? This is not possible out of the box, because NetworkX stores graph data in Python objects (instances of classes Graph, DiGraph, MultiGraph, MultiDiGraph). To have a persistent storage, you need to either pickle the Python object, as explained ",(0,o.kt)("a",{parentName:"p",href:"#store-huge-graph"},"above"),", or ",(0,o.kt)("a",{parentName:"p",href:"/basics#writing-graphs"},"export")," it to a number of different formats. Another solution is to use persistent storage, along with NetworkX, as explained in the ",(0,o.kt)("a",{parentName:"p",href:"#persistent-storage"},"answer above"),"."),(0,o.kt)("h3",{id:"python-performance"},"Why does NetworkX's Python implementation affects its performance?"),(0,o.kt)("p",null,"The big issue with NetworkX is memory usage with large graphs. Since NetworkX stores graph data in Python objects, it can't handle tens of millions of objects without eating up your memory. This leads to out-of-memory errors when working with that large graphs. It is much better to use C/C++ solutions out there. Their scaling is much better, especially when performing different kind of graph algorithms. To learn more about those differences, head over to ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=pythonperformance"},(0,o.kt)("strong",{parentName:"a"},"our resources")),", and find out more about Memgraph, C++ tool with easy usage for Python developers."),(0,o.kt)("h3",{id:"load-graph"},"Is it possible to load a graph with millions of nodes and edges with NetworkX?"),(0,o.kt)("p",null,"NetworkX uses dictionaries and each edge uses at least 100 bytes of memory. Therefore, if you have around 30 millions of edges, you will probably need more than 40 GB of RAM. You can try running this on a larger machine, but if you don't have that kind of resources, then turn to more optimized solutions. An alternative to NetworkX is called Memgraph, an open source in-memory graph database, easy to use for Python developers. To learn how to use it, check out the ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=loadgraph"},(0,o.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website."),(0,o.kt)("h3",{id:"networkx-vs-graph-db"},"What is better to use? NetworkX or a graph database?"),(0,o.kt)("p",null,"It depends on your use case. If you need to store your data and you expect that it's going to change often, it's best to use a graph database. NetworkX is used for processing data, rather than storing it. NetworkX holds a set of useful graph algorithms which can come in handy when gathering insights from your data. But, if you are looking for the best of both worlds, you need a persistent in-memory graph database which holds a set of highly optimized graph algorithms, and which offers a possiblity to still use NetworkX library and algorithms. Memgraph suits the description, so head over to the ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=networkxvsgraphdb"},(0,o.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," to learn more."),(0,o.kt)("h3",{id:"generated-graph"},"Is there a way not to load one of the NetworkX generated graph each time?"),(0,o.kt)("p",null,"Sadly, no. Since NetworkX is holding graph as an in-memory Python object, as explained ",(0,o.kt)("a",{parentName:"p",href:"#store-graph-info"},"above"),", it has to load the graph created with NetworkX graph generator each time. To avoid this, you need to start using a ",(0,o.kt)("a",{parentName:"p",href:"#persistent-storage"},"persistent database solution"),". "),(0,o.kt)("h2",{id:"graph-drawing"},"Graph drawing"),(0,o.kt)("h3",{id:"drawing-solutions"},"Are there any other solutions to draw my NetworkX graphs with?"),(0,o.kt)("p",null,"There are a couple of solutions out there to draw your NetworkX graphs with. NetworkX offers basic support for Matplotlib and Graphviz, which is not that performant. Better graph visualization tools out there are Cytoscape, Gephi, and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/memgraph/orb"},(0,o.kt)("strong",{parentName:"a"},"Orb")),". "),(0,o.kt)("h3",{id:"drawing-large-graph"},"Why is the drawing of my NetworkX graph with about 50000 nodes and edges taking forever?"),(0,o.kt)("p",null,"The drawing of your graph is probably taking too long because that amount of nodes and edges for NetworkX is too huge. NetworkX is not primarily a drawing tool, and you should find better solutions out there. One of them is Memgraph, an in-memory open source graph database, which has a visual user interface called Memgraph Lab. Memgraph Lab offers you quick rendering of large graph with pretty default view and the possiblity of customization. Read more about it at ",(0,o.kt)("a",{parentName:"p",href:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=drawinglargegraph"},(0,o.kt)("strong",{parentName:"a"},"Memgraph for NetworkX developers"))," website."),(0,o.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,o.kt)("p",null,"If you ran into at least one of the above issues with NetworkX, maybe it's time you check what's else out there! Check out the valuable resources for NetworkX and Python developers in general on Memgraph's website:"),(0,o.kt)(n.Z,{title:"Memgraph for NetworkX developers",url:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=faq&utm_content=ctabutton",mdxType:"CtaButton"}),(0,o.kt)("p",null,"If you have been using NetworkX for one of your projects, you\u2019ve probably noticed some of its limitations. Memgraph solves data persistence, allows you to run queries and graph algorithms, and create visualizations you can interact with and customize. It is free to use as it\u2019s open-source."),(0,o.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/xYjGBcm0Yqk",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))}m.isMDXComponent=!0}}]);