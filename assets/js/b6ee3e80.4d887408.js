"use strict";(self.webpackChunknetworkx_guide=self.webpackChunknetworkx_guide||[]).push([[112],{3905:(e,r,t)=>{t.d(r,{Zo:()=>m,kt:()=>u});var a=t(7294);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=a.createContext({}),p=function(e){var r=a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},m=function(e){var r=p(e.components);return a.createElement(l.Provider,{value:r},e.children)},c={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},h=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),h=p(t),u=n,g=h["".concat(l,".").concat(u)]||h[u]||c[u]||o;return t?a.createElement(g,s(s({ref:r},m),{},{components:t})):a.createElement(g,s({ref:r},m))}));function u(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var o=t.length,s=new Array(o);s[0]=h;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var p=2;p<o;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5136:(e,r,t)=>{t.d(r,{Z:()=>o});var a=t(7294);const n={ctaButton:"ctaButton_fu4n",ctaBox:"ctaBox_gZT4"};function o(e){const{title:r,url:t}=e;return a.createElement("div",{className:n.ctaBox},a.createElement("a",{href:t,className:n.ctaButton,style:n},r))}},3248:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>p,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>m});var a=t(7462),n=(t(7294),t(3905)),o=t(5136);const s={slug:"/algorithms/graph-traversals",title:"Graph traversals"},i=void 0,l={unversionedId:"algorithms/graph-traversals/overview",id:"algorithms/graph-traversals/overview",title:"Graph traversals",description:"Graph traversal is a process of visiting every node in the graph. Think of a postman that has to visit all of the houses in your block. Some nodes can be visited more than once. Usually, it is necessary to remember which nodes were previously visited to revisit those nodes as infrequently as possible.",source:"@site/docs/algorithms/graph-traversals/overview.mdx",sourceDirName:"algorithms/graph-traversals",slug:"/algorithms/graph-traversals",permalink:"/algorithms/graph-traversals",draft:!1,editUrl:"https://github.com/memgraph/networkx-guide/edit/main/docs/algorithms/graph-traversals/overview.mdx",tags:[],version:"current",frontMatter:{slug:"/algorithms/graph-traversals",title:"Graph traversals"},sidebar:"networkx_guide",previous:{title:"Algorithms overview",permalink:"/algorithms"},next:{title:"Breadth-first search",permalink:"/algorithms/graph-traversals/bfs"}},p={},m=[{value:"Learn more",id:"learn-more",level:2}],c={toc:m};function h(e){let{components:r,...t}=e;return(0,n.kt)("wrapper",(0,a.Z)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Graph traversal is a process of visiting every node in the graph. Think of a postman that has to visit all of the houses in your block. Some nodes can be visited more than once. Usually, it is necessary to remember which nodes were previously visited to revisit those nodes as infrequently as possible."),(0,n.kt)("p",null,"There are two main graph traversal algorithms: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/algorithms/graph-traversals/bfs"},(0,n.kt)("strong",{parentName:"a"},"breadth-first search"))," (BFS), "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/algorithms/graph-traversals/dfs"},(0,n.kt)("strong",{parentName:"a"},"depth-first search"))," (DFS). ")),(0,n.kt)("h2",{id:"learn-more"},"Learn more"),(0,n.kt)("p",null,"There are many graph algorithms libraries out there, with their own implementations of graph traversal algorithms. NetworkX's algorithms are written in Python, and there are many other libraries that offer faster C++ implementations, such as ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/memgraph/mage"},(0,n.kt)("strong",{parentName:"a"},"MAGE")),", a graph algorithms library developed by Memgraph team."),(0,n.kt)(o.Z,{title:"Memgraph for NetworkX developers",url:"https://memgraph.com/memgraph-for-networkx?utm_source=networkx-guide&utm_medium=referral&utm_campaign=networkx_ppp&utm_term=graphtraversals%2Boverview&utm_content=ctabutton",mdxType:"CtaButton"}))}h.isMDXComponent=!0}}]);